# -*- coding: utf-8 -*-
"""1. 넘파이.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LZfy353_rt5tyqcNVJrdT45UovSnbTk5

# **1. 넘파이(Numpy)**
* 파이썬에서 사용되는 과학 및 수학 연산을 위한 강력한 라이브러리
* 주로 다차원 배열을 다루는 데에 특화되어 있어, 데이터 분석, 머신러닝, 과학 계산 등 다양한 분야에서 널리 사용
* 넘파이 배열은 c언어로 구현되어 있어 연산이 빠르고 효율적
* 넘파이 배열은 큰 데이터셋에서 수치 연산을 수행할 때 뛰어난 성능을 보이며, 메모리 사용을 최적화하고 효율적으로 관리
"""

!pip install numpy

"""# **2. 넘파이의 주요 특징과 기능**

### 2-1. 다차원 배열(N-dimensional array)
* 넘파이의 핵심은 다차원 배열 ndarray
* ndarray는 동일한 자료형을 가지는 원소들로 이루어져 있음
"""

list1 = [1, 2, 3, 4]
print(list1)
print(type(list1))
print(type(list1[0]))

list2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
print(list2)
print(type(list2))
print(type(list2[0]))

import numpy as np

ndarr1 = np.array([1, 2, 3, 4]) # np.array 함수 안에 리스트를 넣으면 자료형이 ndarray가 됨
print(ndarr1)
print(type(ndarr1))
print(type(ndarr1[0]))

ndarr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(ndarr2)
print(type(ndarr2))
print(type(ndarr2[0]))

"""### 2-2. 리스트와 ndarray 변환"""

# 리스트를 ndarray로 변환
li1 = [1, 2, 3, 4]
ndarr1 = np.array(li1)
print(ndarr1)
print(type(ndarr1))

# ndarray를 리스트로 변환
li2 = ndarr1.tolist()
print(li2)
print(type(li2))

"""### 2-3. ndarray의 데이터 타입
* 넘파이의 ndarray는 동일한 자료형을 가지는 원소들로 이루어져 있으며, 다양한 데이터 타입을 지원
"""

li1 = [1, 3.14, 'Python', '🐹', True]
print(li1) # 리스트 내 요소들의 타입이 다 다르지만 에러 X
print(type(li1))
print(type(li1[0]))
print(type(li1[1]))
print(type(li1[2]))
print(type(li1[3]))
print(type(li1[4]))

ndarr1 = np.array([1, 2, 3, 4])
print(ndarr1)
print(type(ndarr1))
print(type(ndarr1[0]))
print(type(ndarr1[1]))

ndarr2 = np.array([1, 2, 3.14, 4])
print(ndarr2) # 정수가 다 실수로 바뀜 (요소 중 가장 큰 데이터타입으로 변환됨)
print(type(ndarr2))
print(type(ndarr2[0]))
print(type(ndarr2[2]))

ndarr3 = np.array([1, 2, 3.14, True])
print(ndarr3)
print(type(ndarr3))
print(type(ndarr3[2]))
print(type(ndarr3[3]))

ndarr4 = np.array(['1', 2, 3.14, True])
print(ndarr4)
print(type(ndarr4))
print(type(ndarr4[0]))
print(type(ndarr4[1]))

ndarr3 = np.array([1, 2, 3.14, True], dtype=int) # 모든 요소를 int형으로 변환
print(ndarr3)
print(type(ndarr3))
print(type(ndarr3[2]))
print(type(ndarr3[3]))

ndarr4 = np.array(['1', 2, 3.14, True], dtype=int) # 문자열 안이 숫자라면 형변환이 됨. 문자열 안에 문자가 있으면 에러남
print(ndarr4)
print(type(ndarr4))
print(type(ndarr4[0]))
print(type(ndarr4[1]))

# ndarr4 = np.array(['일', 2, 3.14, True], dtype=int)
# ValueError: invalid literal for int() with base 10: '일'

"""### 2-4. ndarray 인덱싱과 슬라이싱"""

ndarr1 = np.array(['🐹', '😺', '🙈', '🐸', '🐻'])
print(ndarr1)
print(ndarr1.shape) # 차원을 튜플로 알려줌

# 인덱싱 -> 차원 축소됨
print(ndarr1[0])
print(ndarr1[4])
print(ndarr1[-1])
print(ndarr1[-2])

# 슬라이싱 -> 차원 그대로
print(ndarr1[0:3])
print(ndarr1[2:])
print(ndarr1[:3])

# 2차원 배열
ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])
print(ndarr2d)
print(ndarr2d.shape) # 3개의 행, 4개의 열

# 0행 가져오기
print(ndarr2d[0, :])
print(ndarr2d[0,])
print(ndarr2d[0]) # 행을 가져올 땐 생략 가능

# 0열 가져오기
print(ndarr2d[:, 0]) # :도 생략 불가능

"""### 2-5. Fancy Indexing
* 정수 배열이나 불리언 배열을 사용하여 배열의 일부를 선택하는 방법
* 여러 개의 요소를 한 번에 선택하거나 조건에 맞게 선택할 수 있음
"""

ndarr1 = np.array([10, 16, 2, 8, 20, 90, 85, 44, 23, 32])
idx = [2, 5, 9]
ndarr1[idx]

ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])
ndarr2d[[0, 1], :]

"""### 2-6. Boolean Indexing
* 불리언 값으로 이루어진 배열을 사용하여 조건을 충족하는 원소만 선택하는 방법
"""

ndarr1 = np.array(['🐹', '😺', '🙈', '🐸', '🐻'])
sel = [True, False, True, True, False] # 개수 맞아야 함
ndarr1[sel]

ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])
ndarr2d[ndarr2d > 7]

"""# **3. 행렬 연산**
* 넘파이에서는 다차원 배열인 ndarray를 사용하여 행렬 연산을 수행
* 행렬 연산은 선형 대수와 관련이 깊어서 데이터 과학, 머신러닝, 통계 등 다양한 분야에서 사용
"""

ndarr1 = np.array([[1, 2, 3],
                 [2, 3, 4]])
ndarr2 = np.array([[3, 4, 5],
                   [1, 2, 3]])
print(ndarr1.shape)
print(ndarr2.shape)

# 행렬 덧셈
ndarr1 + ndarr2

# 행렬 뺄셈
ndarr1 - ndarr2

# 행렬 원소별 곱셈
ndarr1 * ndarr2

# 행렬 나눗셈
ndarr1 / ndarr2

# 행렬곱(matrix multiplication)
# 행렬곱의 조건: 맞닿는 shape가 같아야함. 떨어져 있는 shape가 결과 행렬이 됨
# (n, m) @ (m, p) -> (n, p)
# 선형 변환을 표현하고 계산하는 도구로 사용(행렬의 공간을 다른 공간으로 변환하는 작업)
# 선형 연립 방정식을 행렬 형태로 나타내고 이를 풀기 위해 행렬 곱을 사용

ndarr3 = np.array([[1, 2, 3],
                   [1, 2, 3],
                   [2, 3, 4]])
ndarr4 = np.array([[1, 2],
                   [3, 4],
                   [5, 6]])
print(ndarr3.shape)
print(ndarr4.shape)

print((1*1 + 2*3 + 3*5), (1*2 + 2*4 + 3*6))
print((1*1 + 2*3 + 3*5), (1*2 + 2*4 + 3*6))
print((2*1 + 3*3 + 4*5), (2*2 + 3*4 + 4*6))

ndarr3 @ ndarr4

np.dot(ndarr3, ndarr4) # 내적

# 전치 행렬
# 기존 행렬의 행과 열을 바꾼 새로운 행렬
print(ndarr1)
print(ndarr1.T)

# 역행렬
# 주어진 정사각 행렬에 대한 곱셈 연산으로 단위 행렬을 얻을 수 있는 행렬
# 단위행렬: 주대각선의 원소가 모두 1이고, 나머지 원소가 모두 0인 정사각형 행렬

arr = np.array([[1, 2],
                [3, 4]])
print(arr)
print(np.linalg.inv(arr))
print(arr @ np.linalg.inv(arr))

"""# **4. 순차적인 값 생성**"""

arr1 = range(1, 11)
print(arr1) # range 객체로 만들어짐
print(type(arr1))

for i in arr1:
  print(i, end=' ')

arr2 = np.arange(1, 11)
print(arr2)
print(type(arr2)) # 반환되는 값은 ndarray 형태

for i in arr2:
  print(i, end=' ')

"""# **5. 정렬**

"""

ndarr1 = np.array([1, 10, 5, 7, 2, 4, 3, 6, 8, 9])
print(ndarr1)
print(np.sort(ndarr1)) # 오름차순
print(ndarr1) # 원본 배열은 변하지 않음. 즉 in-place 연산이 되지 않음
print(np.sort(ndarr1)[::-1]) # 내림차순

ndarr2d = np.array([[11, 10, 12, 9],
                   [3, 1, 4, 2],
                   [5, 6, 7, 8]])
print(ndarr2d)
print(np.sort(ndarr2d, axis=0)) # 행을 기준으로 정렬
print(np.sort(ndarr2d, axis=1)) # 열을 기준으로 정렬
print(np.sort(ndarr2d, axis=1)[:, ::-1]) # 열을 기준으로 내림차순 정렬
print(np.sort(ndarr2d, axis=-1)) # 축의 마지막 방향

